<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver axidma v3_00_a: axidma v3_00_a
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>axidma v3_00_a </h1>
<p>
This is the driver API for the AXI DMA engine.<p>
For a full description of DMA features, please see the hardware spec. This driver supports the following features:<p>
<ul>
<li>Scatter-Gather DMA (SGDMA)</li><li>Interrupts</li><li>Programmable interrupt coalescing for SGDMA</li><li>APIs to manage Buffer Descriptors (BD) movement to and from the SGDMA engine</li></ul>
<p>
<b>Transactions</b><p>
The object used to describe a transaction is referred to as a Buffer Descriptor (BD). Buffer descriptors are allocated in the user application. The user application needs to set buffer address, transfer length, and control information for this transfer. The control information includes SOF and EOF. Definition of those masks are in <a class="el" href="xaxidma__hw_8h.html">xaxidma_hw.h</a><p>
<b>Scatter-Gather DMA</b><p>
SGDMA allows the application to define a list of transactions in memory which the hardware will process without further application intervention. During this time, the application is free to continue adding more work to keep the Hardware busy.<p>
User can check for the completion of transactions through polling the hardware, or interrupts.<p>
SGDMA processes whole packets. A packet is defined as a series of data bytes that represent a message. SGDMA allows a packet of data to be broken up into one or more transactions. For example, take an Ethernet IP packet which consists of a 14 byte header followed by a 1 or more bytes of payload. With SGDMA, the application may point a BD to the header and another BD to the payload, then transfer them as a single message. This strategy can make a TCP/IP stack more efficient by allowing it to keep packet header and data in different memory regions instead of assembling packets into contiguous blocks of memory.<p>
<b>BD Ring Management</b><p>
BD rings are shared by the software and the hardware.<p>
The hardware expects BDs to be setup as a linked list. The DMA hardware walks through the list by following the next pointer field of a completed BD. The hardware stops processing when the just completed BD is the same as the BD specified in the Tail Ptr register in the hardware.<p>
The last BD in the ring is linked to the first BD in the ring.<p>
All BD management are done inside the driver. The user application should not directly modify the BD fields. Modifications to the BD fields should always go through the specific API functions.<p>
Within the ring, the driver maintains four groups of BDs. Each group consists of 0 or more adjacent BDs:<p>
<ul>
<li>Free: The BDs that can be allocated by the application with <a class="el" href="xaxidma__bdring_8c.html#a11">XAxiDma_BdRingAlloc()</a>.</li></ul>
<p>
<ul>
<li>Pre-process: The BDs that have been allocated with <a class="el" href="xaxidma__bdring_8c.html#a11">XAxiDma_BdRingAlloc()</a>. These BDs are under application control. The application modifies these BDs through driver API to prepare them for DMA transactions.</li></ul>
<p>
<ul>
<li>Hardware: The BDs that have been enqueued to hardware with <a class="el" href="xaxidma__bdring_8c.html#a13">XAxiDma_BdRingToHw()</a>. These BDs are under hardware control and may be in a state of awaiting hardware processing, in process, or processed by hardware. It is considered an error for the application to change BDs while they are in this group. Doing so can cause data corruption and lead to system instability.</li></ul>
<p>
<ul>
<li>Post-process: The BDs that have been processed by hardware and have been extracted from the Hardware group with <a class="el" href="xaxidma__bdring_8c.html#a14">XAxiDma_BdRingFromHw()</a>. These BDs are under application control. The application can check the transfer status of these BDs. The application use <a class="el" href="xaxidma__bdring_8c.html#a15">XAxiDma_BdRingFree()</a> to put them into the Free group.</li></ul>
<p>
BDs are expected to transition in the following way for continuous DMA transfers: <pre></pre><p>
<pre>         <a class="el" href="xaxidma__bdring_8c.html#a11">XAxiDma_BdRingAlloc()</a>                   <a class="el" href="xaxidma__bdring_8c.html#a13">XAxiDma_BdRingToHw()</a>
   Free ------------------------&gt; Pre-process ----------------------&gt; Hardware
                                                                      |
    /|\                                                               |
     |   <a class="el" href="xaxidma__bdring_8c.html#a15">XAxiDma_BdRingFree()</a>                  <a class="el" href="xaxidma__bdring_8c.html#a14">XAxiDma_BdRingFromHw()</a> |
     +--------------------------- Post-process &lt;----------------------+</pre><p>
<pre> </pre><p>
When a DMA transfer is to be cancelled before enqueuing to hardware, application can return the requested BDs to the Free group using <a class="el" href="xaxidma__bdring_8c.html#a12">XAxiDma_BdRingUnAlloc()</a>, as shown below: <pre></pre><p>
<pre>         <a class="el" href="xaxidma__bdring_8c.html#a12">XAxiDma_BdRingUnAlloc()</a>
   Free &lt;----------------------- Pre-process</pre><p>
<pre> </pre><p>
The API provides functions for BD list traversal:<ul>
<li><a class="el" href="xaxidma__bdring_8h.html#a10">XAxiDma_BdRingNext()</a></li><li><a class="el" href="xaxidma__bdring_8h.html#a11">XAxiDma_BdRingPrev()</a></li></ul>
<p>
These functions should be used with care as they do not understand where one group ends and another begins.<p>
<b>SGDMA Descriptor Ring Creation</b><p>
BD ring is created using <a class="el" href="xaxidma__bdring_8c.html#a6">XAxiDma_BdRingCreate()</a>. The memory for the BD ring is allocated by the application, and it has to be contiguous. Physical address is required to setup the BD ring.<p>
The applicaiton can use <a class="el" href="xaxidma__bdring_8h.html#a5">XAxiDma_BdRingMemCalc()</a> to find out the amount of memory needed for a certain number of BDs. <a class="el" href="xaxidma__bdring_8h.html#a4">XAxiDma_BdRingCntCalc()</a> can be used to find out how many BDs can be allocated for certain amount of memory.<p>
A helper function, <a class="el" href="xaxidma__bdring_8c.html#a7">XAxiDma_BdRingClone()</a>, can speed up the BD ring setup if the BDs have same types of controls, for example, SOF and EOF. After using the <a class="el" href="xaxidma__bdring_8c.html#a7">XAxiDma_BdRingClone()</a>, the application only needs to setup the buffer address and transfer length. Note that certain BDs in one packet, for example, the first BD and the last BD, may need to setup special control information.<p>
<b>Descriptor Ring State Machine</b><p>
There are two states of the BD ring:<p>
<ul>
<li>HALTED (H), where hardware is not running</li></ul>
<p>
<ul>
<li>NOT HALTED (NH), where hardware is running</li></ul>
<p>
The following diagram shows the state transition for the DMA engine:<p>
<pre>
   _____ <a class="el" href="xaxidma__bdring_8c.html#a5">XAxiDma_StartBdRingHw()</a>, or <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a>,   ______
   |   |               or <a class="el" href="xaxidma_8c.html#a8">XAxiDma_Resume()</a>                    |    |
   | H |-----------------------------------------------------&gt;| NH |
   |   |&lt;-----------------------------------------------------|    |           
   -----   <a class="el" href="xaxidma_8c.html#a7">XAxiDma_Pause()</a> or <a class="el" href="xaxidma_8c.html#a5">XAxiDma_Reset()</a>                 ------
 </pre><p>
<b>Interrupt Coalescing</b><p>
SGDMA provides control over the frequency of interrupts through interrupt coalescing. The DMA engine provides two ways to tune the interrupt coalescing:<p>
<ul>
<li>The packet threshold counter. Interrupt will fire once the programmable number of packets have been processed by the engine.</li></ul>
<p>
<ul>
<li>The packet delay timer counter. Interrupt will fire once the programmable amount of time has passed after processing the last packet, and no new packets to process. Note that the interrupt will only fire if at least one packet has been processed.</li></ul>
<p>
<b> Interrupt </b><p>
Interrupts are handled by the user application. Each DMA channel has its own interrupt ID. The driver provides APIs to enable/disable interrupt, and tune the interrupt frequency regarding to packet processing frequency.<p>
<b> Software Initialization </b><p>
To use the DMA engine for transfers, the following setup are required:<p>
<ul>
<li>DMA Initialization using <a class="el" href="xaxidma_8c.html#a4">XAxiDma_CfgInitialize()</a> function. This step initializes a driver instance for the given DMA engine and resets the engine.</li></ul>
<p>
<ul>
<li>BD Ring creation. A BD ring is needed per DMA channel and can be built by calling <a class="el" href="xaxidma__bdring_8c.html#a6">XAxiDma_BdRingCreate()</a>.</li></ul>
<p>
<ul>
<li>Enable interrupts if chose to use interrupt mode. The application is responsible for setting up the interrupt system, which includes providing and connecting interrupt handlers and call back functions, before enabling the interrupts.</li></ul>
<p>
<ul>
<li>Start a DMA transfer: Call <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a> to start a transfer for the first time or after a reset, and <a class="el" href="xaxidma__bdring_8c.html#a13">XAxiDma_BdRingToHw()</a> if the channel is already started. Calling <a class="el" href="xaxidma__bdring_8c.html#a13">XAxiDma_BdRingToHw()</a> when a DMA channel is not running will not put the BDs to the hardware, and the BDs will be processed later when the DMA channel is started through <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a>.</li></ul>
<p>
<b> How to start DMA transactions </b><p>
The user application uses <a class="el" href="xaxidma__bdring_8c.html#a13">XAxiDma_BdRingToHw()</a> to submit BDs to the hardware to start DMA transfers.<p>
For both channels, if the DMA engine is currently stopped (using <a class="el" href="xaxidma_8c.html#a7">XAxiDma_Pause()</a>), the newly added BDs will be accepted but not processed until the DMA engine is started, using <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a>, or resumed, using <a class="el" href="xaxidma_8c.html#a8">XAxiDma_Resume()</a>.<p>
<b> Software Post-Processing on completed DMA transactions </b><p>
If the interrupt system has been set up and the interrupts are enabled, a DMA channels notifies the software about the completion of a transfer through interrupts. Otherwise, the user application can poll for completions of the BDs, using <a class="el" href="xaxidma__bdring_8c.html#a14">XAxiDma_BdRingFromHw()</a> or <a class="el" href="xaxidma__bd_8h.html#a11">XAxiDma_BdHwCompleted()</a>.<p>
<ul>
<li>Once BDs are finished by a channel, the application first needs to fetch them from the channel using <a class="el" href="xaxidma__bdring_8c.html#a14">XAxiDma_BdRingFromHw()</a>.</li></ul>
<p>
<ul>
<li>On the TX side, the application now could free the data buffers attached to those BDs as the data in the buffers has been transmitted.</li></ul>
<p>
<ul>
<li>On the RX side, the application now could use the received data in the buffers attached to those BDs.</li></ul>
<p>
<ul>
<li>For both channels, completed BDs need to be put back to the Free group using <a class="el" href="xaxidma__bdring_8c.html#a15">XAxiDma_BdRingFree()</a>, so they can be used for future transactions.</li></ul>
<p>
<ul>
<li>On the RX side, it is the application's responsibility to have BDs ready to receive data at any time. Otherwise, the RX channel refuses to accept any data if it has no RX BDs.</li></ul>
<p>
<b> Examples </b><p>
We provide three examples to show how to use the driver API:<ul>
<li>One for interrupt mode (example_intr.c), multiple BD/packets transfer</li><li>One for polling mode (example_poll.c), single BD transfer.</li><li>One for polling mode (poll_multi_pkts.c), multiple BD/packets transfer</li></ul>
<p>
<b> Address Translation </b><p>
All buffer addresses and BD addresses for the hardware are physical addresses. The user application is responsible to provide physical buffer address for the BD upon BD ring creation. The user application accesses BD through its virtual addess. The driver maintains the address translation between the physical and virtual address for BDs.<p>
<b> Cache Coherency </b><p>
This driver expects all application buffers attached to BDs to be in cache coherent memory. If cache is used in the system, buffers for transmit MUST be flushed from the cache before passing the associated BD to this driver. Buffers for receive MUST be invalidated before accessing the data.<p>
<b> Alignment </b><p>
For BDs:<p>
Minimum alignment is defined by the constant XAXIDMA_BD_MINIMUM_ALIGNMENT. This is the smallest alignment allowed by both hardware and software for them to properly work.<p>
If the descriptor ring is to be placed in cached memory, alignment also MUST be at least the processor's cache-line size. Otherwise, system instability occurs. For alignment larger than the cache line size, multiple cache line size alignment is required.<p>
Aside from the initial creation of the descriptor ring (see <a class="el" href="xaxidma__bdring_8c.html#a6">XAxiDma_BdRingCreate()</a>), there are no other run-time checks for proper alignment of BDs.<p>
For application data buffers:<p>
Application data buffers may reside on any alignment if DRE is built into the hardware. Otherwise, application data buffer must be word-aligned. The word is defined by XPAR_AXIDMA_0_M_AXIS_MM2S_TDATA_WIDTH for transmit and XPAR_AXIDMA_0_S_AXIS_S2MM_TDATA_WIDTH for receive.<p>
For scatter gather transfers that have more than one BDs in the chain of BDs, Each BD transfer length must be multiple of word too. Otherwise, internal error happens in the hardware.<p>
<b> Error Handling </b><p>
The DMA engine will halt on all error conditions. It requires the software to do a reset before it can start process new transfer requests.<p>
<b> Restart After Stopping </b><p>
After the DMA engine has been stopped (through reset or reset after an error) the software keeps track of the current BD pointer when reset happens, and processing of BDs can be resumed through <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a>.<p>
<b> Limitations </b><p>
This driver does not have any mechanisms for mutual exclusion. It is up to the application to provide this protection.<p>
<b> Hardware Defaults &amp; Exclusive Use </b><p>
After the initialization or reset, the DMA engine is in the following default mode:<ul>
<li>All interrupts are disabled.</li></ul>
<p>
<ul>
<li>Interrupt coalescing counter is 1.</li></ul>
<p>
<ul>
<li>The DMA engine is not running (halted). Each DMA channel is started separately, using <a class="el" href="xaxidma__bdring_8c.html#a5">XAxiDma_StartBdRingHw()</a> if no BDs are setup for transfer yet, or <a class="el" href="xaxidma__bdring_8c.html#a8">XAxiDma_BdRingStart()</a> otherwise.</li></ul>
<p>
The driver has exclusive use of the registers and BDs. All accesses to the registers and BDs should go through the driver interface.<p>
<b> Debug Print </b><p>
To see the debug print for the driver, please put "-DDEBUG" as the extra compiler flags in software platform settings. Also comment out the line in xdebug.h: "#undef DEBUG".<p>
<b>Changes From v1.00a</b><p>
. We have changes return type for <a class="el" href="xaxidma__bd_8c.html#a2">XAxiDma_BdSetBufAddr()</a> from void to int . We added <a class="el" href="xaxidma_8h.html#a3">XAxiDma_LookupConfig()</a> so that user does not need to look for the hardware settings anymore.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jz   05/18/10 First release
 2.00a jz   08/10/10 Second release, added in <a class="el" href="xaxidma__g_8c.html">xaxidma_g.c</a>, <a class="el" href="xaxidma__sinit_8c.html">xaxidma_sinit.c</a>,
                     updated tcl file, added <a class="el" href="xaxidma__porting__guide_8h.html">xaxidma_porting_guide.h</a>
 3.00a jz   11/22/10 Support IP core parameters change
 </pre> <p class="Copyright">
Copyright &copy; 1995-2010 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

